{{$providerName := opts.PackageName | ucFirst -}}
// {{$providerName}}Subscription is required for the provider (unused for HTTP client)
type {{$providerName}}Subscription {
  dummy : String
}

// {{ $providerName }} provides HTTP client methods for the API
provider {{ $providerName }} : {{$providerName}}Subscription {
  // The base URL of the API server
  state baseUrl : String = "{{getFirstServerURL}}"
  
  // Update function for the provider (required)
  fun update {
    void
  }

{{range . -}}
{{$opid := .OperationId -}}
{{$hasParams := .RequiresParamObject -}}
{{$pathParams := .PathParams -}}
{{$responseType := "String" -}}
{{- range .Responses}}{{if eq .StatusCode "200"}}{{if .Contents}}{{range .Contents}}{{$responseType = goTypeToMintType .Schema.TypeDecl}}{{break}}{{end}}{{end}}{{end}}{{end -}}
{{$bodyType := "" -}}
{{- range .Bodies}}{{if .Default}}{{$bodyType = goTypeToMintType .Schema.TypeDecl}}{{break}}{{end}}{{end -}}
  // {{$opid}}{{if .HasBody}} with body{{end}}
  fun {{$opid | lcFirst}}({{if $pathParams}}{{range $i, $param := $pathParams}}{{if $i}}, {{end}}{{$param.ParamName | lcFirst}} : {{goTypeToMintType $param.Schema.TypeDecl}}{{end}}{{end}}{{if $hasParams}}{{if $pathParams}}, {{end}}params : {{$opid}}Params{{end}}{{if .HasBody}}{{if or $pathParams $hasParams}}, {{end}}body : {{$bodyType}}{{end}}) : Promise(Result(Http.ErrorResponse, {{$responseType}})) {
    {{- if .QueryParams}}
    let queryParams =
      [
        {{- range $i, $param := .QueryParams}}
        {{- if $i}},{{end}}
        {{- $mintType := goTypeToMintType $param.Schema.TypeDecl}}
        {{if $param.Required}}
        {"{{$param.ParamName}}", {{mintToStringExpr $mintType (printf "params.%s" ($param.ParamName | lcFirst))}}}
        {{- else}}
        Maybe.map(params.{{$param.ParamName | lcFirst}}, (value : {{$mintType}}) : Tuple(String, String) { {"{{$param.ParamName}}", {{mintToStringExpr $mintType "value"}}} })
        {{- end}}
        {{- end}}
      ]
      |> Array.compact()

    let queryString =
      if Array.isEmpty(queryParams) {
        ""
      } else {
        "?" + String.join(Array.map(queryParams, (param : Tuple(String, String)) { "#{param[0]}=#{param[1]}" }), "&")
      }
    {{- end}}

    let url =
      "#{baseUrl}{{mintPathWithParams .Path .PathParams}}"{{if .QueryParams}} + queryString{{end}}

    let request =
      {{if eq (.Method | lower) "get"}}Http.get(url){{else if eq (.Method | lower) "post"}}Http.post(url){{if .HasBody}}
      |> Http.jsonBody(encode body){{end}}{{else if eq (.Method | lower) "put"}}Http.put(url){{if .HasBody}}
      |> Http.jsonBody(encode body){{end}}{{else if eq (.Method | lower) "delete"}}Http.delete(url){{else if eq (.Method | lower) "patch"}}Http.patch(url){{if .HasBody}}
      |> Http.jsonBody(encode body){{end}}{{else}}Http.get(url){{end}}

    let Ok(httpResponse) =
      await Http.send(request) or return Result.Err({
        headers: Map.empty(),
        type: Http.Error.NetworkError,
        status: 0,
        url: url
      })

    let JSON(object) =
      httpResponse.body or return Result.Err({
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      })

    decode object as {{$responseType}}
    |> Result.mapError((error : Object.Error) : Http.ErrorResponse {
      {
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      }
    })
  }

{{end}}
}
